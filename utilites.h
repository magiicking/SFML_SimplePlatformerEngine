#pragma once

#include "pch.h"

using namespace std;
using namespace concurrency;

////////////////////////////////////////////////////////////
/// \brief Класс, включающий всякие полезные процедуры и структуры.
///
/// 
/// 
/// 
/// 
///
////////////////////////////////////////////////////////////
class utilites
{
public:

	enum class CohenSutherlandCode : uint8_t
	{
		Inside = 0b0000,
		Left = 0b0001,
		Right = 0b0010,
		Bottom = 0b0100,
		Top = 0b1000
	};

	////////////////////////////////////////////////////////////
	/// \brief Растеризованная ячейка.
	///
	/// Структура для хранения координат ячейки, через которую
	/// прошел луч, а также расстояние от ячейки начала луча.
	/// 
	/// 
	///
	////////////////////////////////////////////////////////////
	struct RasterizedCell
	{
	public:

		////////////////////////////////////////////////////////////
		/// \brief х-координата ячейки.
		///
		/// 
		/// 
		/// 
		/// 
		///
		////////////////////////////////////////////////////////////
		int x;

		////////////////////////////////////////////////////////////
		/// \brief у-координата ячейки.
		///
		/// 
		/// 
		/// 
		/// 
		///
		////////////////////////////////////////////////////////////
		int y;

		////////////////////////////////////////////////////////////
		/// \brief Расстояние от ячейки начала луча.
		///
		/// 
		/// 
		/// 
		/// 
		///
		////////////////////////////////////////////////////////////
		float distance;

		////////////////////////////////////////////////////////////
		/// \brief Конструктор.
		///
		/// 
		/// 
		/// 
		/// \param _x     х-координата ячейки.
		/// \param _y     у-координата ячейки.
		/// \param _distance     Расстояние от ячейки начала луча.
		///
		////////////////////////////////////////////////////////////
		RasterizedCell(int _x, int _y, float _distance)
		{
			x = _x;
			y = _y;
			distance = _distance;
		}
	};

	////////////////////////////////////////////////////////////
	/// \brief Хэш-функция указателей.
	///
	/// Если верить интернету, то прям очень хорошая.
	/// 
	/// 
	/// 
	///
	////////////////////////////////////////////////////////////
	template<typename Tval>
	struct PointerHash 
	{
		size_t operator()(const Tval* val) const 
		{
			static const size_t shift = (size_t)log2(1 + sizeof(Tval));
			return (size_t)(val) >> shift;
		}
	};

	////////////////////////////////////////////////////////////
	/// \brief Сравнение указателей.
	///
	/// Почему-то штатное сравнение в сетах у меня не срабатывало.
	/// 
	/// 
	/// 
	///
	////////////////////////////////////////////////////////////
	template<typename Tval>
	struct PointerComparator
	{
		bool operator()(const Tval* obj1, const Tval* obj2) const
		{
			if (obj1 == obj2)
				return true;
			return false;
		}
	};

	////////////////////////////////////////////////////////////
	/// \brief Скалярное произведение двух векторов.
	///
	/// Если оно равно нулю, то вектора перпендикулярны.
	/// Если оно больше нуля, то они сонаправлены.
	/// Если оно меньше нуля, то вектора противоположно направлены.
	/// 
	/// \param vector1     Первый вектор.
	/// \param vector2     Второй вектор.
	///
	////////////////////////////////////////////////////////////
	static float Dot2d(const sf::Vector2f* const vector1, const sf::Vector2f* const vector2);

	////////////////////////////////////////////////////////////
	/// \brief Векторное произведение двух векторов.
	///
	/// Если оно равно нулю, то вектора коллинеарны (параллельны, но могут
	/// смотреть в противоположные стороны).
	/// 
	/// \param vector1     Первый вектор.
	/// \param vector2     Второй вектор.
	///
	////////////////////////////////////////////////////////////
	static float Cross2d(const sf::Vector2f* const vector1, const sf::Vector2f* const vector2);

	////////////////////////////////////////////////////////////
	/// \brief Векторное произведение двух векторов.
	///
	/// Если оно равно нулю, то вектора коллинеарны (параллельны, но могут
	/// смотреть в противоположные стороны).
	/// Вектора: АВ = В - А, АС = С - А.
	/// 
	/// \param А     Точка "начала" векторов.
	/// \param В     Точка конца первого вектора.
	/// \param С     Точка конца второго вектора.
	///
	////////////////////////////////////////////////////////////
	static float CrossAB_AC(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const C);

	////////////////////////////////////////////////////////////
	/// \brief Получение прямой по двум точкам.
	///
	/// Если прямую получить не удалось, то возвращает ложь.
	/// 
	/// 
	/// \param А     Первая точка.
	/// \param В     Вторая точка.
	/// \param result     Вектор-результат: x,y,z - соответственно, коэффициенты а, в, с прямой.
	///
	////////////////////////////////////////////////////////////
	static bool GetLineByPoints(const sf::Vector2f* const A, const sf::Vector2f* const B, sf::Vector3f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Получение пересечения двух прямых.
	///
	/// Если прямые пересекаются, то возвращает истину, а в результат записывается точка.
	/// Если прямые параллельны и совпадают, то возвращает истину, а в результат записывается бесконечность.
	/// Если прямые параллельны и не совпадают, то возвращает ложь, а в результат записываается NAN
	/// 
	/// \param line1     Коэффициенты первой прямой.
	/// \param line2     Коэффициенты второй прямой.
	/// \param result     Вектор-результат. Точка пересечения, либо бесконечность, либо NAN.
	///
	////////////////////////////////////////////////////////////
	static bool GetLinesIntersection(const sf::Vector3f* const line1, const sf::Vector3f* const line2, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static bool GetLinesIntersection(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const C, const sf::Vector2f* const D, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Проверяет равенство числа с плавающей запятой с нулем.
	///
	/// Если модуль числа меньше эпсилон, то возвращает истину, иначе ложь.
	/// 
	/// 
	/// \param value     Проверяемое число.
	///
	////////////////////////////////////////////////////////////
	static bool NearZero(float value);

	////////////////////////////////////////////////////////////
	/// \brief Проверяет, принадлежит ли точка отрезку.
	///
	/// Если х и у-координаты лежат между началом и концом отрезка,
	/// и вектора от начала отрезка к концу и от начала отрезка к точке
	/// компланарны, то точка лежит на отрезке.
	/// 
	/// \param segmentStart     Точка начала отрезка.
	/// \param segmentEnd     Точка конца отрезка.
	/// \param point     Поверяемая точка.
	///
	////////////////////////////////////////////////////////////
	static bool IsPointOnSegment(const sf::Vector2f* const segmentStart, const sf::Vector2f* const segmentEnd, const sf::Vector2f* const point);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static float VectorLenght(const sf::Vector2f* const vect);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static void GetTriangleCenter(const sf::Vector2f* const a1, const sf::Vector2f* const a2, const sf::Vector2f* const a3, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static void GetNormal(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const TriangleCenter, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static vector<RasterizedCell> RasterizeSegment(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const gridOriginPoint, const float gridCellSize);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static bool GetSegmentsIntersection(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const C, const sf::Vector2f* const D, sf::Vector2f* const out);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static bool GetRayAndViewBorderIntersectionPoint(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::FloatRect* const viewRect, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static bool GetRayAndRectCollisionPoint(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::FloatRect* const viewRect, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static uint8_t GetPointCodeCohenSutherland(const sf::Vector2f* const point, const sf::FloatRect* const rect);
};

