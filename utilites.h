#pragma once

#include "pch.h"

using namespace std;
using namespace concurrency;

class MagicGrid;
class MagicGameObject;
enum class ObjectTypeFlags : uint16_t;



////////////////////////////////////////////////////////////
/// \brief Класс, включающий всякие полезные процедуры и структуры.
///
////////////////////////////////////////////////////////////
class utilites
{
public:



	////////////////////////////////////////////////////////////
	/// \brief Бинарные коды расположения точки 
	/// относительно прямоугольника.
	///
	////////////////////////////////////////////////////////////
	enum class CohenSutherlandCode : uint8_t
	{
		Inside = 0b0000,
		Left = 0b0001,
		Right = 0b0010,
		Bottom = 0b0100,
		Top = 0b1000
	};

	////////////////////////////////////////////////////////////
	/// \brief Растеризованная ячейка.
	///
	/// Структура для хранения координат ячейки, через которую
	/// прошел луч, а также расстояние от ячейки начала луча.
	///
	////////////////////////////////////////////////////////////
	struct RasterizedCell
	{
	public:

		////////////////////////////////////////////////////////////
		/// \brief х-координата ячейки.
		///
		////////////////////////////////////////////////////////////
		int x;

		////////////////////////////////////////////////////////////
		/// \brief у-координата ячейки.
		///
		////////////////////////////////////////////////////////////
		int y;

		////////////////////////////////////////////////////////////
		/// \brief Расстояние от ячейки начала луча.
		///
		////////////////////////////////////////////////////////////
		float distance;

		////////////////////////////////////////////////////////////
		/// \brief Конструктор.
		/// 
		/// \param _x     х-координата ячейки.
		/// \param _y     у-координата ячейки.
		/// \param _distance     Расстояние от ячейки начала луча.
		///
		////////////////////////////////////////////////////////////
		RasterizedCell(int _x, int _y, float _distance)
		{
			x = _x;
			y = _y;
			distance = _distance;
		}
	};

	////////////////////////////////////////////////////////////
	/// \brief Хэш-функция указателей.
	///
	/// Если верить интернету, то прям очень хорошая.
	///
	////////////////////////////////////////////////////////////
	template<typename Tval>
	struct PointerHash 
	{
		size_t operator()(const Tval* val) const 
		{
			static const size_t shift = (size_t)log2(1 + sizeof(Tval));
			return (size_t)(val) >> shift;
		}
	};

	////////////////////////////////////////////////////////////
	/// \brief Сравнение указателей.
	///
	/// Почему-то штатное сравнение в сетах у меня не срабатывало.
	///
	////////////////////////////////////////////////////////////
	template<typename Tval>
	struct PointerComparator
	{
		bool operator()(const Tval* obj1, const Tval* obj2) const
		{
			if (obj1 == obj2)
				return true;
			return false;
		}
	};

	////////////////////////////////////////////////////////////
	/// \brief
	///
	////////////////////////////////////////////////////////////
	typedef concurrent_unordered_set<MagicGameObject*, PointerHash<MagicGameObject>, PointerComparator<MagicGameObject>> MagicGameObjectsConcurrensUnorderedSet;
	typedef concurrent_unordered_set<sf::Vector2f*, PointerHash<sf::Vector2f>, PointerComparator<sf::Vector2f>> MagicPointsConcurrensUnorderedSet;

	////////////////////////////////////////////////////////////
	/// \brief Скалярное произведение двух векторов.
	///
	/// Если оно равно нулю, то вектора перпендикулярны.
	/// Если оно больше нуля, то они сонаправлены.
	/// Если оно меньше нуля, то вектора противоположно направлены.
	/// 
	/// \param vector1     Первый вектор.
	/// \param vector2     Второй вектор.
	///
	////////////////////////////////////////////////////////////
	static float Dot2d(const sf::Vector2f* const vector1, const sf::Vector2f* const vector2);

	////////////////////////////////////////////////////////////
	/// \brief Векторное произведение двух векторов.
	///
	/// Если оно равно нулю, то вектора коллинеарны (параллельны, но могут
	/// смотреть в противоположные стороны).
	/// 
	/// \param vector1     Первый вектор.
	/// \param vector2     Второй вектор.
	///
	////////////////////////////////////////////////////////////
	static float Cross2d(const sf::Vector2f* const vector1, const sf::Vector2f* const vector2);

	////////////////////////////////////////////////////////////
	/// \brief Векторное произведение двух векторов.
	///
	/// Если оно равно нулю, то вектора коллинеарны (параллельны, но могут
	/// смотреть в противоположные стороны).
	/// Вектора: АВ = В - А, АС = С - А.
	/// 
	/// \param А     Точка "начала" векторов.
	/// \param В     Точка конца первого вектора.
	/// \param С     Точка конца второго вектора.
	///
	////////////////////////////////////////////////////////////
	static float CrossAB_AC(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const C);

	////////////////////////////////////////////////////////////
	/// \brief Получение прямой по двум точкам.
	///
	/// Если прямую получить не удалось, то возвращает ложь.
	/// 
	/// 
	/// \param А     Первая точка.
	/// \param В     Вторая точка.
	/// \param result     Вектор-результат: x,y,z - соответственно, коэффициенты а, в, с прямой.
	///
	////////////////////////////////////////////////////////////
	static bool GetLineByPoints(const sf::Vector2f* const A, const sf::Vector2f* const B, sf::Vector3f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Получение пересечения двух прямых.
	///
	/// Если прямые пересекаются, то возвращает истину, а в результат записывается точка.
	/// Если прямые параллельны и совпадают, то возвращает истину, а в результат записывается бесконечность.
	/// Если прямые параллельны и не совпадают, то возвращает ложь, а в результат записываается NAN
	/// 
	/// \param line1     Коэффициенты первой прямой.
	/// \param line2     Коэффициенты второй прямой.
	/// \param result     Вектор-результат. Точка пересечения, либо бесконечность, либо NAN.
	///
	////////////////////////////////////////////////////////////
	static bool GetLinesIntersection(const sf::Vector3f* const line1, const sf::Vector3f* const line2, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Заполнить описание.
	///
	/// 
	/// 
	/// 
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static bool GetLinesIntersection(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const C, const sf::Vector2f* const D, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Проверяет равенство числа с плавающей запятой с нулем.
	///
	/// Если модуль числа меньше эпсилон, то возвращает истину, иначе ложь.
	/// 
	/// \param value     Проверяемое число.
	///
	////////////////////////////////////////////////////////////
	static bool NearZero(float value);

	////////////////////////////////////////////////////////////
	/// \brief Проверяет, принадлежит ли точка отрезку.
	///
	/// Если х и у-координаты лежат между началом и концом отрезка,
	/// и вектора от начала отрезка к концу и от начала отрезка к точке
	/// компланарны, то точка лежит на отрезке.
	/// 
	/// \param segmentStart     Точка начала отрезка.
	/// \param segmentEnd     Точка конца отрезка.
	/// \param point     Поверяемая точка.
	///
	////////////////////////////////////////////////////////////
	static bool IsPointOnSegment(const sf::Vector2f* const segmentStart, const sf::Vector2f* const segmentEnd, const sf::Vector2f* const point);

	////////////////////////////////////////////////////////////
	/// \brief Получение длины вектора.
	/// 
	/// \param vect     Вектор, длину которого считаем.
	///
	////////////////////////////////////////////////////////////
	static float VectorLenght(const sf::Vector2f* const vect);

	////////////////////////////////////////////////////////////
	/// \brief Получить центр треугольника по координатам трех точек.
	/// 
	/// \param a1     Первая точка.
	/// \param a2     Вторая точка.
	/// \param a3     Третья точка.
	/// \param result     Точка-результат.
	///
	////////////////////////////////////////////////////////////
	static void GetTriangleCenter(const sf::Vector2f* const a1, const sf::Vector2f* const a2, const sf::Vector2f* const a3, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Получить нормаль грани треугольника.
	///
	/// Нормаль должна быть наружу, для этого ее направление сравнивается
	/// с направлением к центру треугольника.
	/// 
	/// \param A     Первая точка грани.
	/// \param B     Вторая точка грани.
	/// \param TriangleCenter     Координата центра треугольника.
	/// \param result     Вектор-результат.
	///
	////////////////////////////////////////////////////////////
	static void GetNormal(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const TriangleCenter, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Растеризация отрезка.
	///
	/// Получает массив координат ячеек, через которые проходит отрезок,
	/// а также расстояние до каждой ячейки.
	/// 
	/// \param A     Начало отрезка.
	/// \param B     Конец отрезка.
	/// \param gridOriginPoint     "Начало координат" сетки.
	/// \param gridCellSize     Размер ячейки сетки.
	///
	////////////////////////////////////////////////////////////
	static vector<RasterizedCell> RasterizeSegment(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const gridOriginPoint, const float gridCellSize);

	////////////////////////////////////////////////////////////
	/// \brief Получить точку пересечения отрезков.
	///
	/// Если отрезки не пересекаются, возвращает ложь.
	/// 
	/// 
	/// \param A     Начало первого отрезка.
	/// \param B     Конец первого отрезка.
	/// \param C     Начало второго отрезка.
	/// \param D     Конец второго отрезка.
	/// \param out     Полученная точка пересечения.
	///
	////////////////////////////////////////////////////////////
	static bool GetSegmentsIntersection(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::Vector2f* const C, const sf::Vector2f* const D, sf::Vector2f* const out);

	////////////////////////////////////////////////////////////
	/// \brief Получит пересечение луча и границы экрана.
	///
	/// Продляет отрезок до луча и находит точку пересечения с краем экрана.
	/// Если точки отрезка совпадают, возвращает ложь
	/// 
	/// \param A     Точка начала отрезка.
	/// \param B     Точка конца отрезка.
	/// \param viewRect     Прямоугольник экрана.
	/// \param result     Полученная точка пересечения.
	///
	////////////////////////////////////////////////////////////
	static bool GetRayAndViewBorderIntersectionPoint(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::FloatRect* const viewRect, sf::Vector2f* const result);

	////////////////////////////////////////////////////////////
	/// \brief Получает точку пересечения луча и прямоугольника.
	///
	/// Только в случае, если начало луча снаружи прямоугольника.
	/// Определяет пересечение с ближайшей гранью прямоугольника.
	/// Если пересечения нет, то возвращает ложь. 
	///
	/// \param Параметр     Заполнить параметры.
	///
	////////////////////////////////////////////////////////////
	static bool GetRayAndRectCollisionPoint(const sf::Vector2f* const A, const sf::Vector2f* const B, const sf::FloatRect* const viewRect, sf::Vector2f* const result, bool * const blocking);

	////////////////////////////////////////////////////////////
	/// \brief Получает бинарный код расположения точки относительно прямоугольника.
	/// 
	/// \param point     Координаты точки.
	/// \param rect     Прямоугольник.
	///
	////////////////////////////////////////////////////////////
	static uint8_t GetPointCodeCohenSutherland(const sf::Vector2f* const point, const sf::FloatRect* const rect);

	////////////////////////////////////////////////////////////
	/// \brief Сравнивает два вектора.
	///
	/// Если координаты равны, то и векторы равны.
	/// 
	/// \param A     Первый вектор.
	/// \param B     Второй вектор.
	///
	////////////////////////////////////////////////////////////
	static bool VectorsAreEqual(const sf::Vector2f* const A, const sf::Vector2f* const B);

	////////////////////////////////////////////////////////////
	/// \brief Получить объекты ячеек сетки, попадающих в прямоугольную область.
	/// 
	/// \param rect     Прямоугольник.
	/// \param grid     Сетка.
	/// \param testFlag     Флаг, который должен быть установлен у объектов.
	/// \param objectsSet     Сет, в который должны попасть объекты.
	///
	////////////////////////////////////////////////////////////
	static void GetObjectsInRect(const sf::FloatRect* const rect, const MagicGrid* const grid, ObjectTypeFlags testFlag, MagicGameObjectsConcurrensUnorderedSet* const objectsSet);

	////////////////////////////////////////////////////////////
	/// \brief Получить угловые точки объектов ячеек сетки, попадающих в прямоугольную область.
	///
	/// Получаются только те точки, которые расположены на углах объектов, доступных лучу,
	/// то есть не перекрытых гранями объекта.
	/// 
	/// \param rayStart     Точка начала луча.
	/// \param rect     Прямоугольник.
	/// \param grid     Сетка.
	/// \param testFlag     Флаг, который должен быть установлен у объектов.
	/// \param pointsSet     Сет, в который должны попасть точки объектов.
	///
	////////////////////////////////////////////////////////////
	static void GetPointsInRectForRaycast(const sf::Vector2f* const rayStart, const sf::FloatRect* const rect,
		const MagicGrid* const grid,
		ObjectTypeFlags testFlag, MagicPointsConcurrensUnorderedSet* const pointsSet);

	////////////////////////////////////////////////////////////
	/// \brief Получение "нужных" точек объекта.
	///
	/// Вызывается из GetPointsInRectForRaycast для получения точек обрабатываемого объекта.
	/// 
	/// 
	/// \param gameObject     Игровой объект, точки которого получаем.
	/// \param rayStart     Точка начала луча.
	/// \param pointsSet     Сет, в который должны попасть точки объектов.
	///
	////////////////////////////////////////////////////////////
	static void GetPointsInRectForRaycast_HandleGameObject(const MagicGameObject* const gameObject, const sf::Vector2f* const rayStart, MagicPointsConcurrensUnorderedSet* const pointsSet);

	////////////////////////////////////////////////////////////
	/// \brief Проверяет, пересекаются ли два прямоугольника.
	/// 
	/// \param rect1     Первый прямоугольник.
	/// \param rect2     Второй прямоугольник.
	///
	////////////////////////////////////////////////////////////
	static bool RectanglesOverlaping(const sf::FloatRect* const rect1, const sf::FloatRect* const rect2);
};

